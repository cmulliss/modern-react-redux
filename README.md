# modern-react-redux

npm install prettier-eslint react react-redux --save-dev

# Booklist

* our App state is generated by reducer fns
* BooksReducer always returns an [] of books
* The [] contains a list of objects, where each object represents one book
*  we added the BooksReducer to our combined reducer call inside the reducers index file
* this reducer adds a key to our global App state, called books, where the key is 'books' and the value is whatever gets returned from the books reducer, which is this case is our array of books
* created a container BookList, as needed to be aware of state within the redux app
* we promoted it to a container by importing 'connect' fn, then defined mapStateToProps and we hooked our component together with mapStateToProps using the connect fn
* added <BookList /> to App
* redux generated a state object that contained our books, then mapped that state as props to our component because the state was updated through our reducer and re-rendered with the list of books

## action creators and dispatch etc

* bindActionCreators with dispatch, going to take all the actions and make sure they get passed on to all the different reducers

```javascript
  return bindActionCreators({ selectBook: selectBook }, dispatch)
```

* mapDispatch to props, anything returned from this will end up as __props__ on the BookList container.
* we are passing an object with key and value 'selectBook'
* whatever we pass as the first argument is going to be available as props to our container
* can specifically call this.props.selectBook (the key)
* __and that will call our action creator__

```javascript
function mapDispatchToProps (dispatch) {
  // whenever selectBook is called, the result should be
  // passed to all of our reducers
  return bindActionCreators({ selectBook: selectBook }, dispatch)
}
```

* mapStateToProps will promote BookList from a component to a container
* it needs to know about this new dispatch method, selectBook, make it available as a prop

### summary

* want to take some state and map it to the props of our container
* and want to take the action creator and make it available to be called inside the container as well
* selectBook is a totally plain fn, returns a plain js object
* if we just call it, we get the object back inside our component
* so, the purpose of bindActionCreators and dispatch is specifically to take what gets returned from selectBook and make sure it flows through all the reducers

* all reducers get 2 arguments, current state and an action

### mini summary

* most generic case, whre we want to take some state and map it to the props of our container
* and want to take an action creator and make it available to be called inside of the container too
* the action creator, with this bindActionCreators and the dispatch method, the purpose is selectBook is a plain fn, returns a plain js object, if just call it nothing happens,
* so the purpose of __bindActionCreators__ and __dispatch__ is specifically to take what gets returned from selectBook, and make sure it flows through all the reducers

```javascript
function mapStateToProps (state) {
  return {
    books: state.books
  }
}
function mapDispatchToProps (dispatch) {
  return bindActionCreators({ selectBook: selectBook }, dispatch)
}
export default connect(
  mapStateToProps,
  mapDispatchToProps
)(BookList)
```

### actions etc

* an action creator is just a fn that returns an action
* an action is just an object that flows through all of our different reducers
* reducers can then use that action to produce a different value for its particular piece of state

```javascript
// BookList container
import React, { Component } from 'react'
import { connect } from 'react-redux'
// we take the return value from selectBook and make sure it flows through all the reducers with bindActionCreators
import { selectBook } from '../actions/index'
import { bindActionCreators } from 'redux'

// if we add a click event handler to our li, we can then call the action creator
// we have already connected the action creator to this container, made it available as a prop, this.props.selectBook
class BookList extends Component {
  renderList () {
    return this.props.books.map(book => {
      return (
        <li
          key={book.title}
          onClick={() => this.props.selectBook(book)}
          className='list-group-item'
        >
          {book.title}
        </li>
      )
    })
  }
  render () {
    return <ul className='list-group col-sm-4'>{this.renderList()}</ul>
  }
}
function mapStateToProps (state) {
  // Whatever is returned will show up as props inside of BookList
  return {
    books: state.books
  }
}
// anything returned from this fn will end up as props
// on the BookList container
function mapDispatchToProps (dispatch) {
  // whenever selectBook is called, the result should be
  // passed to all of our reducers, using dispatch
  // enables us to call this.props.selectBook, and that
  // will call our action creator
  return bindActionCreators({ selectBook: selectBook }, dispatch)
}
// promote BookList from a component to a container, it needs
// to know about this new dispatch method, selectBook.
// make it available as a prop
// Anything returned from this function will end up as props
// on the BookList container
// function mapDispatchToProps (dispatch) {
// Whenever selectBook is called, the result shoudl be passed
// to all of our reducers
export default connect(
  mapStateToProps,
  mapDispatchToProps
)(BookList)
// Promote BookList from a component to a container - it needs to know
// about this new dispatch method, selectBook. Make it available
// as a prop.
// redux generated a state object that contained our books, than mapped that state as props to our component.
// because the state was updated through our reducer, our component re-rendered with that list of books
```
